image: python:3.12

# Cache pour les dépendances Python
cache:
  paths:
    - .cache/pip
    - venv/

# Définition des stages
stages:
  - test
  - lint
  - docs
  - build
  - deploy

# Variables globales
variables:
  PIP_CACHE_DIR: "$CI_PROJECT_DIR/.cache/pip"
  PYTHONPATH: "$CI_PROJECT_DIR"

# Installation des dépendances
.setup: &setup
  before_script:
    - python -V
    - pip install virtualenv
    - virtualenv venv
    - source venv/bin/activate
    - pip install -r requirements.txt
    - pip install pytest pytest-cov ruff black docformatter sphinx sphinx-rtd-theme

# Job de test
test:
  <<: *setup
  stage: test
  script:
    - pytest --cov=src tests/ --cov-report=xml --cov-report=term-missing --junitxml=test-results.xml
  coverage: '/^TOTAL.*\s+(\d+)%$/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage.xml
      junit: test-results.xml
    paths:
      - coverage.xml
      - test-results.xml
    expire_in: 1 week

# Job de vérification du style de code
lint:
  <<: *setup
  stage: lint
  script:
    # Run ruff and show errors in logs
    - echo "Running ruff..."
    - ruff check src/ tests/ --output-format=gitlab > ruff-code-quality-report.json || true
    - cat ruff-code-quality-report.json
    # Run black and show differences in logs
    - echo "Running black..."
    - black --check --skip-string-normalization src/ tests/ --diff > black.txt || true
    - cat black.txt
    # Run docformatter and show differences in logs
    - echo "Running docformatter..."
    - docformatter --check --wrap-summaries 88 --wrap-descriptions 88 src/ tests/ --recursive > docformatter.txt || true
    - cat docformatter.txt
  artifacts:
    reports:
      codequality: ruff-code-quality-report.json
    paths:
      - ruff-code-quality-report.json
      - black.txt
      - docformatter.txt
    expire_in: 1 week
  allow_failure: true # Permet au pipeline de continuer même si le linting échoue

# Job de génération de documentation
docs:
  <<: *setup
  stage: docs
  script:
    - cd docs
    # Déterminer la version de la documentation
    - |
      if [[ $CI_COMMIT_TAG =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        # Si c'est un tag, utiliser le numéro de version
        VERSION=${CI_COMMIT_TAG#v}
      else
        # Sinon, utiliser 'latest'
        VERSION="latest"
      fi
    # Générer la documentation avec la version appropriée
    - sphinx-build -b html -D version=$VERSION -D release=$VERSION source build
  artifacts:
    paths:
      - docs/build
    expire_in: 1 week

# Job de publication de la documentation
pages:
  <<: *setup
  stage: deploy
  script:
    - cd docs
    # Déterminer la version de la documentation
    - |
      if [[ $CI_COMMIT_TAG =~ ^v?[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        # Si c'est un tag, utiliser le numéro de version
        VERSION=${CI_COMMIT_TAG#v}
        # Créer le dossier de version
        mkdir -p ../public/$VERSION
        # Copier la documentation dans le dossier de version
        cp -r build/* ../public/$VERSION/
      else
        # Pour la branche main, utiliser 'latest'
        mkdir -p ../public/latest
        cp -r build/* ../public/latest/
      fi
    # Copier uniquement le fichier index.html de la page d'accueil dans le dossier public racine
    - cp source/_static/index.html ../public/
    # Générer le fichier versions.json
    - |
      # Récupérer toutes les versions disponibles
      versions=("latest")
      for dir in ../public/*/; do
        if [ -d "$dir" ]; then
          version=$(basename "$dir")
          if [ "$version" != "latest" ]; then
            versions+=("$version")
          fi
        fi
      done
      # Créer le fichier versions.json
      echo "{\"versions\": [$(printf '"%s",' "${versions[@]}" | sed 's/,$//')]}" > ../public/versions.json
  artifacts:
    paths:
      - public
    expire_in: 1 week
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_COMMIT_TAG =~ /^v?[0-9]+\.[0-9]+\.[0-9]+$/'

# Job de création du package
build:
  <<: *setup
  stage: build
  script:
    - python setup.py sdist bdist_wheel
    - echo "Dist directory:"
    - ls -alhR dist/
  artifacts:
    paths:
      - dist/
    expire_in: 1 week

# Règles pour l'exécution du pipeline
workflow:
  rules:
    - if: '$CI_COMMIT_BRANCH == "main"'
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event"'
